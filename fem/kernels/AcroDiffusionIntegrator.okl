// Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at
// the Lawrence Livermore National Laboratory. LLNL-CODE-443211. All Rights
// reserved. See file COPYRIGHT for details.
//
// This file is part of the MFEM library. For more information and source code
// availability see http://mfem.org.
//
// MFEM is free software; you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License (as published by the Free
// Software Foundation) version 2.1 dated February 1999.

#include "Acrotensor.hpp"

// This assembles all of the element mass matrices into Me on the GPU
// All of the double* inputs are assumed to be cuda pointers
extern "C"
void Assemble(const int &ne,                // Number of elements
              const int &nq,                // Number or quadrature points
              const int &nldof,             // Number of local dofs
              double *B_,                   // FE data on quadtature points nq x nldof
              double *Jdet_,                // Determinant of the jacobian ne x nq
              double *w_,                   // Integration weights for the quadrature rule nq
              double *C_,                   // Physical constant ne x nq
              double *M_,                   // Assemble local mass matrices ne x nldof x nldof
              acrobatic::TensorEngine &TE)  // This object caches implementations so hold onto it somewhere
{
   // Make tensors with the external data, currently Acrotensor won't
   // accept GPU only data so we will give it the CUDA pointer for the CPU data.
   // This won't work out well if we try to use acrotensor to do a transfer.  Probably
   // Tensors like B, and W should be created somewhere else and hed ont anyway.
   acrobactic::Tensor B(nq, nldof, B_, B_, true);
   acrobactic::Tensor J(ne, nq, Jdet_, Jdet_, true);
   acrobactic::Tensor W(nq, w_, w_, true);
   acrobactic::Tensor C(ne, nq, C_, C_, true);
   acrobactic::Tensor M(ne, nldof, nldof, M_, M_, true);

   // This computes M(e, i, J) on the GPU assuming TE was initilized
   // with a GPU ready executor like "OneOutPerThread" and all the input data
   // started on the GPU.  Usually this will autotransfer stuff to the GPU,
   // but since we didn't provide the CPU versions of the pointers to the Tensors
   // it can't.
   TE["M_e_i_j = B_k_i B_k_j W_k C_e_k J_e_k"](M, B, B, W, C, J);

   // This version doesn't create any temporary tensors, for instance
   // if we had some scratch space on the GPU we could something like this instead
   // acrobactic::Tensor D(ne, k, scratch1_, scratch1_, true);
   // acrobactic::Tensor H(ne, k, scratch1_, scratch1_, true);
   // TE["H_k_i_j = B_k_i B_k_j"](H, B, B);
   // TE["D_e_k = W_k C_e_k J_e_k"](D, W, C, J);
   // TE["M_e_i_j = H_k_i_j D_e_k"](M, H, D);
}

extern "C"
void Mult(const int &ne,                // Number of elements
          const int &nq,                // Number or quadrature points
          const int &nldof,             // Number of local dofs}
          double *M_,                   // Assemble local mass matrices ne x nldof x nldof
          acrobatic::TensorEngine &TE)  // This object caches implementations so hold onto it somewhere
{}